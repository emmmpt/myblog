#### 如何产生闭包

当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时,就产生了闭包

#### 闭包到底是什么

> 用chrome 可以查看

- 理解一: 闭包是嵌套的内部函数(绝大多数人)
- 理解二:包含被引用变量(函数)的对象(极少数人)
- 注意: 闭包存在于嵌套的内部函数中

#### 产生闭包的条件

- 函数嵌套
- 内部函数引用了外部函数的数据
  - **执行内部函数定义就会产生闭包(不用调用函数)**

> 虽然引入变量也能产生闭包,但是不能产生实际效果。

#### 常见的闭包

1. 将函数作为另一个函数的返回值

2. 将函数作为实参传递给另一个函数调用

   1. ```js
      function showDelay(msg,time){
        setTimeout(function (){
          alert(msg)
        },time)
      }
      ```

#### 闭包的作用

1. 使用函数内部的变量在执行函数之后,仍然存活在内存中(延长了局部变量的生命周期)

2. 让函数外部可以操作(读写)到函数内部的变量(变量/函数)

   **问题:**

   1. 函数执行完后，函数内部声明的局部变量是否还存在？

      - 一般不存在，存在于闭包中的变量才可能存在

#### 闭包的生命周期

1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用的时候)
2. 死亡: 在嵌套的内部函数成为垃圾对象时

#### 闭包的应用:定义`js`模块

- 具有特定功能的`js`文件

- 将所有的数据和功能封装在一个函数内部(私有的)

- 只向外暴露一个包含n个方法的对象或函数

- 模块的使用者,只需要通过模块暴露的对象调用方法

  **最优应用**

  ```js
  (function (window){//防止后面向外暴露方法的window被压缩
    //私有数据
    var msg = 'My atguigu'
    //操作数据的函数
    function doSomething(){
      console.log('doSomething()'+ msg.toUpperCase())
    }
    function doOtherthing(){
      console.log('doOtherthing()'+ msg.toLowerCase())
    }
    window.mymodule = {// 向外暴露对象(给外部使用的方法)
      doSomething: doSomething,
      doOtherthing:doOtherthing
    }
  })()
  ```

#### 闭包的缺点及解决

1. 缺点
   1. 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
   2. 容易造成内存泄漏
2. 解决
   1. 能不用就不用闭包
   2. 及时释放`f =null`//让内部函数成为垃圾对象-->回收闭包

##### 内存溢出与内存泄漏

1. 内存溢出
   - 一种程序运行出现的错误
   - 当程序运行需要的内存超过了剩余的内存时,就抛出内存溢出的错误
2. 内存泄漏
   - 占用的内存没有及时释放
   - 内存泄漏积累多了就容易导致内存溢出
   - 常见的内存泄漏
     - 意外的全局变量
     - 没有及时清理的计时器或回调函数
     - 闭包

#### 两种垃圾回收策略

找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。

共有两种策略：

- **标记清除法**
- **引用计数法**

##### 标记清除法

垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。

**它的实现原理就是通过判断一个变量是否在执行环境中被引用，来进行标记删除。**

##### 引用计数法

引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。

当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。

**存在的缺陷：**

两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。

> 最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。

####  如何管理内存

虽然说是 `js` 的内存都是自动管理的，但是对于 `js`  还是存在一些问题的，最主要的一个问题就是**分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少**。

> 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做**解除引用**。

- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。
- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）

> 补充：因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。

#### 廖雪峰博客实例

```javascript
function count() {
  var arr = [];
  for (var i = 1; i <= 3; i++) {
    arr.push(function() {
      return i * i;
    });
  }
  return arr;
}
var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
f1(); // 16
f2(); // 16
f3(); // 16
```

- 上面代码的运行流程：
  - 因为循环体执行了 push 方法，将一个个函数`function () { return i * i;}`添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以 for 循环依次执行，直到`i = 4`。因为闭包，内部函数`function () { return i * i;}`引用的`i`就是外部变量，for 循环中的`i = 4`。所以，之后数组`arr`内的函数的`i`都是 4。
- 调用函数`count`后，变量`results`已经是数组`arr`了。数组里面元素依次是`function f1() { return i * i;} function f2() { return i * i;} function f3() { return i * i;}`。但是三个函数都没有被调用，直到`var f1 = results[0];`，此时`function f1() { return i * i;}`开始执行，如上段所写，此时的`i = 4`，所以，返回值就是 16 了。后面两个调用也是类似情况

```javascript
// 定义数字0:
var zero = function(f) {
  return function(x) {
    return x;
  };
};
// 定义数字1:
var one = function(f) {
  return function(x) {
    return f(x);
  };
};
// 定义加法:
function add(n, m) {
  return function(f) {
    return function(x) {
      return m(f)(n(f)(x));
    };
  };
}
// 计算数字2 = 1 + 1:
var two = add(one, one);
// 计算数字3 = 1 + 2:
var three = add(one, two);
// 计算数字5 = 2 + 3:
var five = add(two, three);
// 你说它是3就是3，你说它是5就是5，你怎么证明？
// 呵呵，看这里:
// 给3传一个函数,会打印3次:
three(function() {
  console.log('print 3 times');
})();
// 给5传一个函数,会打印5次:
five(function() {
  console.log('print 5 times');
})();
```

